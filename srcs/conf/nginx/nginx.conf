load_module modules/ngx_http_modsecurity_module.so;
# -----------------------------------------------------------------------------
# Nginx + ModSecurity v3 (OWASP CRS) - Minimal, production-ready skeleton
# -----------------------------------------------------------------------------

# With the owasp/modsecurity-crs:nginx image the module is already available.
# Uncomment only if you build your own image with a dynamic module:

#user  nginx;
worker_processes 1;

# In production use warn/error
error_log  /var/log/nginx/error.log warn;
# For debugging only
# error_log  /var/log/nginx/error.log info;
pid        /tmp/nginx.pid;

events { worker_connections  1024; } 

http {
  include       /etc/nginx/mime.types;
  default_type  application/octet-stream;

  # Rate limit zone for login (6 req/min per IP)
  limit_req_zone $binary_remote_addr zone=login:10m rate=1r/s;
  # Optional: log reason for rate limiting in error.log
  # limit_req_log_level error;

  sendfile        on;
  tcp_nopush      on;
  tcp_nodelay     on;
  keepalive_timeout  65;
  server_tokens off;
  
  # ------------------ ModSecurity ------------------
  # Enable ModSecurity globally. It can move these directives into a specific
  # 'server' block if on prefer enabling WAF per vhost.
  modsecurity on;
  modsecurity_rules_file /etc/modsecurity.d/modsecurity.conf;

  # ------------------ Upstream to our app ------------------
  upstream frontend_backend  {
    server frontend:8080;  # Change host:port to our backend service (adjust if your SPA runs elsewhere)
    keepalive 32;
  }

  #  upstream api_backend {
  #    server api:3000;        # adjust to our API service/port
  #    keepalive 32;
  #  }

  # ------------------ HTTP -> HTTPS redirect ------------------
  server {
    listen 8080 default_server;
    listen [::]:8080 default_server;
    server_name _;

    # Optional: allow ACME HTTP-01 challenge if you use Let's Encrypt
    location ^~ /.well-known/acme-challenge/ {
      root /var/www/html;
    }

    location / {
      return 308 https://$host:8443$request_uri;
    }
  }

  # ------------------ HTTPS reverse proxy with WAF ------------------
  server {
    listen 443 ssl;
    listen [::]:443 ssl;
    http2 on;
    server_name localhost; # replace with your domain if you have one

    # TLS (replace with real certs; or mount your own via ./conf/certs)
    ssl_certificate     /srcs/secrets/certs/fullchain.pem;
    ssl_certificate_key /srcs/secrets/certs/privkey.pem;
    ssl_protocols       TLSv1.2 TLSv1.3;
    ssl_ciphers         HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;

    # Body size limit (align with ModSecurity SecRequestBodyLimit if you need large uploads)
    client_max_body_size 12m;

    # Security headers (adjust to our app needs)
    add_header X-Content-Type-Options nosniff always;
    add_header X-Frame-Options SAMEORIGIN always;
    add_header Referrer-Policy strict-origin-when-cross-origin always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload" always;
    add_header Permissions-Policy "geolocation=(), microphone=()" always;
    add_header X-Content-Type-Options nosniff always;
    add_header X-Frame-Options SAMEORIGIN always;
    add_header Referrer-Policy strict-origin-when-cross-origin always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Content-Security-Policy "default-src 'self';" always;

    # Block access to hidden files and directories, except .well-known
    location ~ /\.(?!well-known) {
        deny all;
    }

    # Proxy to frontend (optimized with upstream and keepalive)
    location / {        
        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_read_timeout   60s;
        proxy_connect_timeout 60s;
        proxy_send_timeout    60s;

        proxy_http_version 1.1;
        proxy_set_header Connection "";

      #  proxy_pass http://frontend:8080;
        proxy_pass http://frontend_backend;
    }
    
    # --- API under /api/ ---
    # Rate limit para login (6/min => la 7ª -> 429)
    # Rate-limit SOLO en el endpoint de login
    location = /api/auth/login {
        # 6 req/min per IP, 7th in the same window ⇒ 429     
        limit_req zone=login burst=6 nodelay;
        limit_req_status 429;
                
        # Simulated backend (no service) -> 502 for the first 6
        proxy_pass http://127.0.0.1:9;

    }
    # Rate limit for registration (6/min => 7th -> 429)
    # Protects the registration endpoint from abuse/bots
    location = /api/auth/register {
        limit_req zone=login burst=6 nodelay;
        limit_req_status 429;
        proxy_pass http://127.0.0.1:9;
    }
    # Rate limit for password recovery (6/min => 7th -> 429)
    # Protects the password recovery endpoint from abuse/enumeration
    location = /api/auth/forgot-password {
        limit_req zone=login burst=6 nodelay;
        limit_req_status 429;
        proxy_pass http://127.0.0.1:9;
    }
    # Rate limit for password reset (6/min => 7th -> 429)
    # Protects the password reset endpoint from abuse/enumeration
    location = /api/auth/reset-password {
        limit_req zone=login burst=6 nodelay;
        limit_req_status 429;
        proxy_pass http://127.0.0.1:9;
    }

    # The rest of /api/ without rate limiting
    location /api/ {        
        proxy_pass http://127.0.0.1:9;
    } 

    # Optional: serve static assets directly (tune path)
    # location /static/ {
    #   root /var/www/html;
    #   access_log off;
    #   expires 7d;
    # }
    
  }
}
