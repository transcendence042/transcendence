# =============================================================================
# ModSecurity Core Configuration for Docker/Nginx + OWASP CRS
# Mode: Prevention (blocking)
# Logs: Enabled (audit + optional debug)
# Notes:
# - Custom rules use ids in the 200000+ range here. Consider switching to
#   9xxxx range to avoid potential overlaps with external rule sets.
# =============================================================================


# -- Rule engine initialization ----------------------------------------------

# Enable ModSecurity for all transactions.
# On  = blocking mode (recommended for production once tuned)
# DetectionOnly = log only (recommended during initial tuning)
#
SecRuleEngine On



# -- Request body handling ---------------------------------------------------

# Allow ModSecurity to inspect request bodies (e.g., POST params).
#
SecRequestBodyAccess On


# Enable XML body processor when Content-Type indicates XML.
#
SecRule REQUEST_HEADERS:Content-Type "(?:application(?:/soap\+|/)|text/)xml" \
     "id:'200000',phase:1,t:none,t:lowercase,pass,nolog,ctl:requestBodyProcessor=XML"

# Enable JSON body processor when Content-Type is application/json.
#
SecRule REQUEST_HEADERS:Content-Type "application/json" \
     "id:'200001',phase:1,t:none,t:lowercase,pass,nolog,ctl:requestBodyProcessor=JSON"

# Maximum sizes to mitigate DoS via oversized bodies.
# Adjust if your app legitimately needs larger uploads.
#
SecRequestBodyLimit 13107200
SecRequestBodyNoFilesLimit 131072
SecRequestBodyInMemoryLimit 131072

# Action when body exceeds limits.
# Reject is appropriate in blocking mode.
#
SecRequestBodyLimitAction Reject

# Fail closed on request body parsing errors.
#
SecRule REQBODY_ERROR "!@eq 0" \
"id:'200002', phase:2,t:none,log,deny,status:400,msg:'Failed to parse request body.',logdata:'%{reqbody_error_msg}',severity:2"

# Strict validation for multipart/form-data (can be set to DetectionOnly if too strict).
#
SecRule MULTIPART_STRICT_ERROR "!@eq 0" \
"id:'200003',phase:2,t:none,log,deny,status:400, \
msg:'Multipart request body failed strict validation: \
PE %{REQBODY_PROCESSOR_ERROR}, \
BQ %{MULTIPART_BOUNDARY_QUOTED}, \
BW %{MULTIPART_BOUNDARY_WHITESPACE}, \
DB %{MULTIPART_DATA_BEFORE}, \
DA %{MULTIPART_DATA_AFTER}, \
HF %{MULTIPART_HEADER_FOLDING}, \
LF %{MULTIPART_LF_LINE}, \
SM %{MULTIPART_MISSING_SEMICOLON}, \
IQ %{MULTIPART_INVALID_QUOTING}, \
IP %{MULTIPART_INVALID_PART}, \
IH %{MULTIPART_INVALID_HEADER_FOLDING}, \
FL %{MULTIPART_FILE_LIMIT_EXCEEDED}'"

# Detect unmatched multipart boundaries (1 = critical mismatch).
#
SecRule MULTIPART_UNMATCHED_BOUNDARY "@eq 1" \
    "id:'200004',phase:2,t:none,log,deny,msg:'Multipart parser detected a possible unmatched boundary.'"



# -- PCRE / Regex tuning -----------------------------------------------------

# Avoid potential ReDoS via excessive backtracking.
# Tune upwards if you see false positives from CRS (e.g., 2000-5000).
#
SecPcreMatchLimit 1000
SecPcreMatchLimitRecursion 1000

# Deny on internal ModSecurity engine flags.
#
SecRule TX:/^MSC_/ "!@streq 0" \
        "id:'200005',phase:2,t:none,deny,msg:'ModSecurity internal error flagged: %{MATCHED_VAR_NAME}'"



# -- Response body handling --------------------------------------------------

# Usually keep OFF for performance unless you need leakage detection.
#
SecResponseBodyAccess Off

# MIME types to inspect if response body access is enabled.
#
SecResponseBodyMimeType text/plain text/html text/xml

# Response buffering limit (only applies if ResponseBodyAccess On).
#
SecResponseBodyLimit 524288
SecResponseBodyLimitAction ProcessPartial



# -- Filesystem configuration ------------------------------------------------

# Temp and persistent data directories (ensure they exist and are private in the container).
#
SecTmpDir /tmp/
SecDataDir /tmp/



# -- File uploads handling (optional) ----------------------------------------

# If you need to store/upload intercepted files, configure these and ensure paths exist.
#SecUploadDir /opt/modsecurity/var/upload/
#SecUploadKeepFiles RelevantOnly
#SecUploadFileMode 0600



# -- Debug log configuration (optional) --------------------------------------

# Enable when actively tuning; keep OFF in production for performance.
#SecDebugLog /var/log/modsecurity/modsec_debug.log
#SecDebugLogLevel 0



# -- Audit log configuration -------------------------------------------------

# Log relevant transactions (5xx and 4xx except 404) and those marked by rules.
#
SecAuditEngine RelevantOnly
SecAuditLogRelevantStatus "^(?:5|4(?!04))"

# Log parts to capture full context for investigations.
SecAuditLogParts ABIJDEFHZ

# Serial logging is simplest in containers. For high throughput, consider concurrent.
#
SecAuditLogType Serial
SecAuditLog /var/log/modsecurity/modsec_audit.log
#SecAuditLogStorageDir /opt/modsecurity/var/audit/



# -- Miscellaneous -----------------------------------------------------------

# Standard form-urlencoded separator and cookie format.
#
SecArgumentSeparator &
SecCookieFormat 0

# Unicode mapping used by urlDecodeUni transformation.
#
SecUnicodeMapFile unicode.mapping 20127

# Telemetry about ModSecurity build. Disable in production to reduce info exposure.
#
SecStatusEngine Off



# -- Secure defaults and baseline hardening ----------------------------------

# Default disruptive action for phases 1 and 2: deny and log with 403.
# CRS will often override actions; these serve as secure fallbacks.
#
SecDefaultAction "phase:1,deny,log,status:403"
SecDefaultAction "phase:2,deny,log,status:403"

# Restrict allowed HTTP methods (adjust if your app needs others like PUT/DELETE).
#
SecRule REQUEST_METHOD "!^(GET|POST|HEAD|DELETE|PUT)$" \
     "id:'200010',phase:1,deny,log,status:405,msg:'HTTP method not allowed'"

# Basic directory traversal prevention across typical collections.
#
SecRule ARGS|ARGS_NAMES|REQUEST_HEADERS|REQUEST_URI|REQUEST_FILENAME "\.\./" \
     "id:'200011',phase:2,t:none,deny,log,status:403,msg:'Directory Traversal attempt'"

# Basic SQLi signatures (CRS provides much better coverage; this is an extra belt).
#
SecRule ARGS "(?i:(union\s+select|select.+from|insert\s+into|drop\s+table))" \
     "id:'200012',phase:2,t:none,deny,log,status:403,msg:'Possible SQL Injection'"

# Basic XSS signatures (again, CRS covers this broadly).
#
SecRule ARGS "(?i:(<script\b|onerror=|onload=|alert\s*\())" \
     "id:'200013',phase:2,t:none,deny,log,status:403,msg:'Possible XSS attack'"

# Block obviously malicious/scanner User-Agents (tune to your traffic).
#
SecRule REQUEST_HEADERS:User-Agent "(?i:\b(curl|wget|nikto|sqlmap|nessus|python-requests)\b)" \
     "id:'200014',phase:1,t:none,deny,log,status:403,msg:'Suspicious User-Agent blocked'"

# Cap parameter name length to reduce abuse (tune threshold to your app).
#
SecRule ARGS_NAMES ".{50,}" \
     "id:'200015',phase:2,t:none,deny,log,status:403,msg:'Parameter name too long'"

# Optional: block unexpected content-types for POST (uncomment to enforce strictness).
#
#SecRule REQUEST_METHOD "POST" "id:'200016',phase:1,chain,deny,log,status:415,msg:'Unsupported Content-Type for POST'"
#    SecRule REQUEST_HEADERS:Content-Type "!^(application/x-www-form-urlencoded|multipart/form-data|application/json)(?:;|$)" "t:none"



# -- OWASP Core Rule Set (CRS) ----------------------------------------------

# Make sure CRS is installed in these paths inside the container image.
# For owasp/modsecurity-crs:nginx, these defaults are correct.
#
Include /etc/modsecurity.d/owasp-crs/crs-setup.conf
Include /etc/modsecurity.d/owasp-crs/rules/*.conf